# ADR-071: Orchestrator Agent for Workflow Management

**Status**: Accepted  
**Date**: 2026-01-20  
**Deciders**: AgentX Team  
**Issue**: #71

---

## Context

AgentX implements a multi-agent workflow system with 5 core agents (Product Manager, Architect, UX Designer, Engineer, Reviewer) coordinated via orchestration labels (`orch:*-done`). While `.github/workflows/agent-orchestrator.yml` handles automatic routing, we lacked:

1. A **formal agent definition** for the orchestrator itself
2. **Manual control** for debugging and overrides
3. **Explicit workflow commands** (pause, resume, skip, retry)
4. **Error recovery** mechanisms documented as agent behavior

This ADR documents the decision to create a dedicated **Orchestrator Agent** as a meta-agent that manages workflow state and routing.

---

## Decision

### 1. Create Orchestrator as a Meta-Agent

The Orchestrator is a **meta-agent** distinct from content-creating agents:

| Aspect | Content Agents (PM, Architect, etc.) | Orchestrator Agent |
|--------|--------------------------------------|---------------------|
| **Purpose** | Create artifacts (PRD, ADR, code) | Manage workflow state |
| **Trigger** | Specific issue types + labels | All `orch:*` label changes |
| **Output** | Documents, code, designs | Routing decisions, comments |
| **Handoff** | To next agent in sequence | Coordinates all agents |
| **Error Handling** | Report failures | Detect and recover |

### 2. Dual-Mode Operation

#### Automatic Mode (Event-Driven)
- **File**: `.github/workflows/agent-orchestrator.yml`
- **Trigger**: `issues: labeled` events for `orch:*` labels
- **Use Case**: Normal operation, zero-touch handoffs
- **SLA**: <30 seconds for handoffs

#### Manual Mode (On-Demand)
- **File**: `.github/workflows/run-orchestrator.yml`
- **Trigger**: `workflow_dispatch` with issue_number input
- **Use Case**: Debugging, overrides, recovery
- **Commands**: `route`, `pause`, `resume`, `skip`, `retry`

### 3. Workflow State Machine

The Orchestrator implements this state machine:

```
┌─────────────────────────────────────────────────────────────┐
│ type:epic                                                   │
│ ├─ No orch:pm-done → Product Manager                       │
│ ├─ orch:pm-done, no orch:ux-done → UX Designer (sequential)│
│ ├─ orch:ux-done, no orch:architect-done → Architect      │
│ └─ orch:architect-done → Unblock child Stories            │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│ type:story / type:feature                                   │
│ ├─ Prerequisites check (parent Epic completion)            │
│ ├─ No orch:engineer-done → Engineer                        │
│ └─ orch:engineer-done → Reviewer                           │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│ type:bug / type:docs                                        │
│ ├─ No orch:engineer-done → Engineer                        │
│ └─ orch:engineer-done → Reviewer                           │
└─────────────────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────────────────┐
│ type:spike                                                  │
│ ├─ No orch:architect-done → Architect                      │
│ └─ orch:architect-done → Close                             │
└─────────────────────────────────────────────────────────────┘
```

### 4. Prerequisite Validation

Before routing to Engineer, the Orchestrator validates:

```javascript
function canRouteToEngineer(storyIssue) {
  const parentEpic = getParentEpic(storyIssue);
  
  if (!parentEpic) {
    // Standalone story - check if it needs design
    return !hasLabel(storyIssue, 'needs:ux');
  }
  
  // Check parent Epic completion
  const hasArchitectDone = hasLabel(parentEpic, 'orch:architect-done');
  const hasUxDone = hasLabel(parentEpic, 'orch:ux-done');
  const needsUx = hasLabel(storyIssue, 'needs:ux') || hasLabel(parentEpic, 'needs:ux');
  
  if (!hasArchitectDone) {
    blockIssue(storyIssue, 'Waiting for Architect to complete Tech Spec');
    return false;
  }
  
  if (needsUx && !hasUxDone) {
    blockIssue(storyIssue, 'Waiting for UX Designer to complete wireframes');
    return false;
  }
  
  return true;
}
```

### 5. Error Recovery

The Orchestrator handles common failures:

| Error | Detection Method | Recovery Action |
|-------|------------------|-----------------|
| Agent timeout | No `orch:*-done` after 15 min | Add `needs:help` label + comment |
| Missing artifacts | Label exists but no files committed | Remove label, re-trigger workflow |
| Blocked issue | Prerequisites not met | Add blocking comment, pause routing |
| Circular dependency | Issue references itself | Add `needs:resolution` + notify |
| Test failures | CI pipeline fails | Add `needs:fixes` + reassign |

### 6. Workflow Commands

Support for manual control via workflow inputs:

```bash
# Route to next agent (default)
gh workflow run run-orchestrator.yml -f issue_number=71 -f command=route

# Pause workflow
gh workflow run run-orchestrator.yml -f issue_number=71 -f command=pause

# Resume workflow
gh workflow run run-orchestrator.yml -f issue_number=71 -f command=resume

# Skip agent stage (not recommended)
gh workflow run run-orchestrator.yml -f issue_number=71 -f command=skip -f target_agent=architect

# Retry current stage
gh workflow run run-orchestrator.yml -f issue_number=71 -f command=retry
```

---

## Consequences

### Positive

✅ **Centralized Coordination**: Single source of truth for workflow routing logic  
✅ **Explicit Agent Role**: Orchestrator documented like other agents  
✅ **Manual Override**: Debugging and recovery via workflow_dispatch  
✅ **Error Recovery**: Built-in handling for common failure modes  
✅ **Metrics Tracking**: Foundation for SLA monitoring and reporting  
✅ **Sequential Coordination**: Enforces PM→UX→Architect→Engineer workflow (user-centered design)  
✅ **Clear Documentation**: State machine and routing rules explicitly defined

### Negative

⚠️ **Added Complexity**: One more agent to understand and maintain  
⚠️ **Potential Duplication**: Some logic exists in both agent-orchestrator.yml and run-orchestrator.yml  
⚠️ **Manual Commands Risk**: Users could bypass workflow rules with `/skip`

### Mitigations

- **Complexity**: Agent definition file serves as comprehensive documentation
- **Duplication**: run-orchestrator.yml is lightweight wrapper, core logic in agent-orchestrator.yml
- **Manual Risk**: Commands log to issue comments, creating audit trail

---

## Implementation

### Files Created

1. **Agent Definition**: `.github/agents/orchestrator.agent.md`
   - Role description and responsibilities
   - State machine documentation
   - Prerequisite validation logic
   - Error handling strategies
   - MCP tool usage examples

2. **Manual Workflow**: `.github/workflows/run-orchestrator.yml`
   - workflow_dispatch trigger with inputs
   - Command execution (route, pause, resume, skip, retry)
   - Issue state inspection
   - Agent workflow triggering
   - Comment posting for audit trail

3. **Documentation Updates**: `AGENTS.md`
   - Added Orchestrator to agent table
   - Documented workflow commands
   - Added state machine diagram
   - Linked to orchestrator files

4. **Architecture Decision**: `docs/adr/ADR-071.md` (this file)

### Integration

The Orchestrator integrates with existing infrastructure:

- **Automatic Mode**: Via existing `.github/workflows/agent-orchestrator.yml`
- **Manual Mode**: New `.github/workflows/run-orchestrator.yml`
- **Configuration**: Uses `.github/orchestration-config.yml` routing rules
- **Labels**: Same `orch:*` labels for state tracking
- **MCP Tools**: Same GitHub MCP Server tools (run_workflow, update_issue, etc.)

### Testing Strategy

1. **Unit Tests**: Routing logic validation (in E2E test suite)
2. **Integration Tests**: Full workflow with manual orchestrator invocation
3. **Error Tests**: Timeout, missing artifacts, circular deps
4. **Command Tests**: Each workflow command (pause, resume, skip, retry)

---

## Alternatives Considered

### Alternative 1: Keep Only agent-orchestrator.yml

**Pros**: Simpler, no duplication  
**Cons**: No manual control, difficult to debug, no explicit agent definition

**Rejected**: Manual override is essential for debugging and recovery.

### Alternative 2: Implement as Separate Service

**Pros**: More scalable, can use complex routing logic, database for state  
**Cons**: Much more complex, requires infrastructure, overkill for current needs

**Rejected**: GitHub Actions + MCP Server sufficient for current scale.

### Alternative 3: Embed Logic in Each Agent

**Pros**: Fully decentralized, agents make own routing decisions  
**Cons**: No single source of truth, difficult to coordinate parallel work, hard to debug

**Rejected**: Centralized orchestration provides better coordination and visibility.

---

## References

- **Issue**: #71 - Create Orchestrator Agent for Workflow Management
- **Agent Definition**: [.github/agents/orchestrator.agent.md](../.github/agents/orchestrator.agent.md)
- **Automatic Workflow**: [.github/workflows/agent-orchestrator.yml](../.github/workflows/agent-orchestrator.yml)
- **Manual Workflow**: [.github/workflows/run-orchestrator.yml](../.github/workflows/run-orchestrator.yml)
- **AGENTS.md**: Orchestrator documentation section
- **MCP Integration**: [docs/mcp-integration.md](mcp-integration.md)
- **Testing Guide**: [docs/orchestration-testing-guide.md](orchestration-testing-guide.md)

---

**Version**: 1.0  
**Last Updated**: January 20, 2026  
**Author**: AgentX Team
