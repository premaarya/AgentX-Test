# Process Ready Issues (Polling-Based Orchestrator)
# Runs every 5 minutes to check for issues with status:ready label
# More reliable than issues: event trigger which can miss events
# Part of AgentX Phase 1 MVP

name: Process Ready Issues

on:
  # Run every 5 minutes
  schedule:
    - cron: '*/5 * * * *'
  
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - show what would be processed without actually processing'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  issues: write
  actions: write

jobs:
  find-and-process:
    name: Find and Process Ready Issues
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Find ready issues and route to agents
        uses: actions/github-script@v7
        with:
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            
            console.log(`ðŸ” Scanning for ready issues... (dry_run: ${dryRun})`);
            
            // Fetch all open issues with status:ready label
            const readyIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'status:ready',
              per_page: 100
            });
            
            console.log(`Found ${readyIssues.data.length} issues with status:ready`);
            
            // Define routing rules
            const routingRules = [
              {
                name: 'Epic â†’ Product Manager',
                match: (labels) => labels.includes('type:epic') && !labels.some(l => l.startsWith('stage:')),
                workflow: 'run-product-manager.yml',
                getInputs: (issue) => ({
                  issue_number: issue.number,
                  issue_title: issue.title,
                  issue_body: issue.body || ''
                })
              },
              {
                name: 'Feature with needs:ux â†’ UX Designer',
                match: (labels) => labels.includes('type:feature') && labels.includes('needs:ux') && !labels.some(l => l.startsWith('stage:')),
                workflow: 'run-ux-designer.yml',
                getInputs: (issue) => ({
                  issue_number: String(issue.number),
                  workflow_type: 'ux-first',
                  stage: '1'
                })
              },
              {
                name: 'Feature â†’ Architect',
                match: (labels) => labels.includes('type:feature') && !labels.includes('needs:ux') && !labels.some(l => l.startsWith('stage:')),
                workflow: 'run-architect.yml',
                getInputs: (issue) => ({
                  issue_number: String(issue.number),
                  workflow_type: 'feature',
                  stage: '1'
                })
              },
              {
                name: 'Story with needs:ux â†’ UX Designer',
                match: (labels) => labels.includes('type:story') && labels.includes('needs:ux') && !labels.some(l => l.startsWith('stage:')),
                workflow: 'run-ux-designer.yml',
                getInputs: (issue) => ({
                  issue_number: String(issue.number),
                  workflow_type: 'ux-first',
                  stage: '1'
                })
              },
              {
                name: 'Story â†’ Architect',
                match: (labels) => labels.includes('type:story') && !labels.includes('needs:ux') && !labels.some(l => l.startsWith('stage:')),
                workflow: 'run-architect.yml',
                getInputs: (issue) => ({
                  issue_number: String(issue.number),
                  workflow_type: 'story',
                  stage: '1'
                })
              },
              {
                name: 'Bug â†’ Engineer',
                match: (labels) => labels.includes('type:bug') && !labels.some(l => l.startsWith('stage:')),
                workflow: 'run-engineer.yml',
                getInputs: (issue) => ({
                  issue_number: String(issue.number),
                  workflow_type: 'bug',
                  stage: '1'
                })
              },
              {
                name: 'Spike â†’ Architect',
                match: (labels) => labels.includes('type:spike') && !labels.some(l => l.startsWith('stage:')),
                workflow: 'run-architect.yml',
                getInputs: (issue) => ({
                  issue_number: String(issue.number),
                  workflow_type: 'spike',
                  stage: '1'
                })
              },
              {
                name: 'Stage Complete â†’ Next Agent',
                match: (labels) => labels.includes('orchestration:stage-complete'),
                workflow: null, // Special handling
                handler: async (issue, labels) => {
                  // Determine next stage based on current stage
                  const currentStage = labels.find(l => l.startsWith('stage:') && !l.includes('-done'));
                  const hasUx = labels.includes('needs:ux');
                  
                  const stageOrder = hasUx 
                    ? ['stage:ux-designer', 'stage:architect', 'stage:engineer', 'stage:reviewer']
                    : ['stage:architect', 'stage:engineer', 'stage:reviewer'];
                  
                  const currentIndex = stageOrder.findIndex(s => labels.includes(s));
                  
                  if (currentIndex === -1 || currentIndex >= stageOrder.length - 1) {
                    console.log(`  â†’ Workflow complete for #${issue.number}`);
                    return null;
                  }
                  
                  const nextStage = stageOrder[currentIndex + 1];
                  const workflowMap = {
                    'stage:ux-designer': 'run-ux-designer.yml',
                    'stage:architect': 'run-architect.yml',
                    'stage:engineer': 'run-engineer.yml',
                    'stage:reviewer': 'run-reviewer.yml'
                  };
                  
                  return {
                    workflow: workflowMap[nextStage],
                    inputs: {
                      issue_number: String(issue.number),
                      workflow_type: labels.includes('type:feature') ? 'feature' : 'story',
                      stage: String(currentIndex + 2)
                    }
                  };
                }
              }
            ];
            
            // Process each ready issue
            const processed = [];
            const skipped = [];
            
            for (const issue of readyIssues.data) {
              const labels = issue.labels.map(l => l.name);
              console.log(`\nðŸ“‹ Issue #${issue.number}: ${issue.title}`);
              console.log(`   Labels: ${labels.join(', ')}`);
              
              // Skip if already being processed
              if (labels.includes('status:in-progress') || labels.includes('orchestration:active')) {
                console.log(`   â­ï¸ Skipping - already in progress`);
                skipped.push({ number: issue.number, reason: 'Already in progress' });
                continue;
              }
              
              // Find matching rule
              let matched = false;
              for (const rule of routingRules) {
                if (rule.match(labels)) {
                  console.log(`   âœ… Matched rule: ${rule.name}`);
                  
                  let workflowToTrigger = rule.workflow;
                  let inputs = rule.getInputs ? rule.getInputs(issue) : null;
                  
                  // Handle special rules with custom handlers
                  if (rule.handler) {
                    const result = await rule.handler(issue, labels);
                    if (!result) {
                      skipped.push({ number: issue.number, reason: 'Handler returned null' });
                      matched = true;
                      break;
                    }
                    workflowToTrigger = result.workflow;
                    inputs = result.inputs;
                  }
                  
                  if (dryRun) {
                    console.log(`   ðŸ”¸ DRY RUN: Would trigger ${workflowToTrigger}`);
                    console.log(`   ðŸ”¸ Inputs: ${JSON.stringify(inputs)}`);
                  } else {
                    // Mark as in-progress to prevent duplicate processing
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: ['status:in-progress', 'orchestration:active']
                    });
                    
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        name: 'status:ready'
                      });
                    } catch (e) {
                      // Label might not exist
                    }
                    
                    // Trigger the workflow with error handling
                    console.log(`   ðŸš€ Triggering ${workflowToTrigger}`);
                    try {
                      await github.rest.actions.createWorkflowDispatch({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        workflow_id: workflowToTrigger,
                        ref: 'master',
                        inputs: inputs
                      });
                      
                      processed.push({ 
                        number: issue.number, 
                        workflow: workflowToTrigger,
                        rule: rule.name 
                      });
                    } catch (dispatchError) {
                      console.log(`   âš ï¸ Failed to trigger workflow: ${dispatchError.message}`);
                      
                      // Revert labels on failure
                      await github.rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        labels: ['status:ready']
                      });
                      
                      try {
                        await github.rest.issues.removeLabel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issue.number,
                          name: 'orchestration:active'
                        });
                        await github.rest.issues.removeLabel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issue.number,
                          name: 'status:in-progress'
                        });
                      } catch (e) { /* ignore */ }
                      
                      skipped.push({ 
                        number: issue.number, 
                        reason: `Workflow trigger failed: ${dispatchError.message.substring(0, 50)}` 
                      });
                    }
                  }
                  
                  matched = true;
                  break;
                }
              }
              
              if (!matched) {
                console.log(`   â“ No matching rule found`);
                skipped.push({ number: issue.number, reason: 'No matching rule' });
              }
            }
            
            // Summary
            console.log(`\n${'='.repeat(60)}`);
            console.log(`ðŸ“Š SUMMARY`);
            console.log(`${'='.repeat(60)}`);
            console.log(`âœ… Processed: ${processed.length}`);
            processed.forEach(p => console.log(`   - #${p.number} â†’ ${p.workflow} (${p.rule})`));
            console.log(`â­ï¸ Skipped: ${skipped.length}`);
            skipped.forEach(s => console.log(`   - #${s.number}: ${s.reason}`));
