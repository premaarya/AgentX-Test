# Multi-Agent Orchestrator
# Main trigger workflow that routes issues to appropriate agent workflows
# Part of AgentX Phase 1 MVP
# Note: GitHub may show phantom 'failure' on push for this workflow - ignore these.

name: Multi-Agent Orchestrator

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]
  # Manual trigger for testing
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process'
        required: true
        type: number

# Prevent concurrent orchestration on same issue
concurrency:
  group: orchestrate-${{ github.event.issue.number || 'manual' }}
  cancel-in-progress: false

jobs:
  # ==========================================================================
  # ROUTER: Determine which workflow to trigger
  # ==========================================================================
  route:
    name: Route to Agent
    runs-on: ubuntu-latest
    outputs:
      workflow: ${{ steps.route.outputs.workflow }}
      agent: ${{ steps.route.outputs.agent }}
      should_run: ${{ steps.route.outputs.should_run }}
      stage: ${{ steps.route.outputs.stage }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse orchestration config
        id: config
        run: |
          echo "Config loaded from .github/orchestration-config.yml"

      - name: Determine routing
        id: route
        uses: actions/github-script@v7
        with:
          script: |
            // Handle manual dispatch - fetch issue data
            let issue, comment, labels;
            
            if (context.eventName === 'workflow_dispatch') {
              const issueNum = ${{ inputs.issue_number || 0 }};
              if (issueNum === 0) {
                console.log('No issue number provided for manual dispatch');
                core.setOutput('should_run', 'false');
                return;
              }
              const response = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNum
              });
              issue = response.data;
              labels = issue.labels.map(l => l.name);
              comment = null;
              console.log(`Manual dispatch for issue #${issueNum}`);
            } else {
              issue = context.payload.issue;
              comment = context.payload.comment;
              labels = issue.labels.map(l => l.name);
            }
            
            console.log(`Processing issue #${issue.number}: ${issue.title}`);
            console.log(`Labels: ${labels.join(', ')}`);
            
            // Store issue number for downstream jobs
            core.setOutput('issue_number', issue.number);            
            // Check if orchestration is paused
            if (labels.includes('orchestration:paused')) {
              console.log('Orchestration is paused for this issue');
              core.setOutput('should_run', 'false');
              return;
            }
            
            // Check for slash commands in comments
            if (comment) {
              const body = comment.body.trim().toLowerCase();
              
              if (body.startsWith('/pause')) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['orchestration:paused']
                });
                console.log('Workflow paused');
                core.setOutput('should_run', 'false');
                return;
              }
              
              if (body.startsWith('/resume')) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'orchestration:paused'
                }).catch(() => {});
                // Continue with routing
              }
              
              if (body.startsWith('/skip')) {
                const parts = body.split(' ');
                if (parts.length > 1) {
                  const skipAgent = parts[1];
                  console.log(`Skipping ${skipAgent} stage`);
                  // Remove current stage label and advance
                  // This will be handled by the state update below
                }
              }
              
              if (body.startsWith('/route ')) {
                const agent = body.replace('/route ', '').trim();
                if (['architect', 'engineer', 'reviewer', 'ux-designer'].includes(agent)) {
                  console.log(`Manual route to: ${agent}`);
                  core.setOutput('should_run', 'true');
                  core.setOutput('agent', agent);
                  core.setOutput('workflow', 'manual');
                  return;
                }
              }
              
              // If comment doesn't trigger anything, don't run
              if (!body.startsWith('/orchestrate') && !body.startsWith('/resume') && !body.startsWith('/retry')) {
                core.setOutput('should_run', 'false');
                return;
              }
            }
            
            // Routing rules based on labels
            // Check for needs:ux modifier first
            const needsUx = labels.includes('needs:ux');
            
            const routingRules = [
              // Epic - triggers Product Manager for PRD and backlog creation
              { labels: ['type:epic'], workflow: 'epic', stages: ['product-manager'] },
              // Feature with UX requirement - prepend ux-designer
              { labels: ['type:feature'], needsUx: true, workflow: 'feature-ux', stages: ['ux-designer', 'architect', 'engineer', 'reviewer'] },
              { labels: ['type:story'], needsUx: true, workflow: 'feature-ux', stages: ['ux-designer', 'architect', 'engineer', 'reviewer'] },
              // Standard feature workflow
              { labels: ['type:feature'], workflow: 'feature', stages: ['architect', 'engineer', 'reviewer'] },
              { labels: ['type:story'], workflow: 'feature', stages: ['architect', 'engineer', 'reviewer'] },
              { labels: ['type:bug'], workflow: 'bug', stages: ['engineer', 'reviewer'] },
              { labels: ['type:spike'], workflow: 'spike', stages: ['architect'] },
              { labels: ['type:ux'], workflow: 'ux', stages: ['ux-designer', 'architect', 'engineer'] },
              { labels: ['type:docs'], workflow: 'docs', stages: ['engineer'] },
              { labels: ['type:refactor'], workflow: 'feature', stages: ['architect', 'engineer', 'reviewer'] },
              { labels: ['type:security'], workflow: 'security', stages: ['reviewer', 'engineer', 'reviewer'] },
            ];
            
            // Find matching rule (needs:ux rules are first, so they match before standard rules)
            let matchedRule = null;
            for (const rule of routingRules) {
              // Check if rule requires needs:ux and if label is present
              if (rule.needsUx && !needsUx) continue;
              if (rule.labels.some(l => labels.includes(l))) {
                matchedRule = rule;
                break;
              }
            }
            
            if (!matchedRule) {
              console.log('No routing rule matched. Skipping orchestration.');
              core.setOutput('should_run', 'false');
              return;
            }
            
            console.log(`Matched workflow: ${matchedRule.workflow}`);
            
            // Determine current stage from labels
            const stageLabels = labels.filter(l => l.startsWith('stage:'));
            let currentStageIndex = 0;
            
            if (stageLabels.length > 0) {
              const currentStage = stageLabels[0].replace('stage:', '');
              currentStageIndex = matchedRule.stages.indexOf(currentStage);
              
              // If current stage is complete, advance to next
              if (labels.includes('orchestration:stage-complete')) {
                currentStageIndex++;
                // Remove stage-complete label
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'orchestration:stage-complete'
                }).catch(() => {});
              }
            }
            
            // Check if workflow is complete
            if (currentStageIndex >= matchedRule.stages.length) {
              console.log('Workflow complete!');
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['orchestration:complete']
              });
              core.setOutput('should_run', 'false');
              return;
            }
            
            const nextAgent = matchedRule.stages[currentStageIndex];
            console.log(`Next agent: ${nextAgent} (stage ${currentStageIndex + 1}/${matchedRule.stages.length})`);
            
            // Update stage label
            for (const oldLabel of stageLabels) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: oldLabel
              }).catch(() => {});
            }
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: [`stage:${nextAgent}`, 'orchestration:active']
            });
            
            core.setOutput('should_run', 'true');
            core.setOutput('workflow', matchedRule.workflow);
            core.setOutput('agent', nextAgent);
            core.setOutput('stage', currentStageIndex + 1);

  # ==========================================================================
  # DISPATCH: Trigger the appropriate agent workflow
  # ==========================================================================
  dispatch:
    name: Dispatch to ${{ needs.route.outputs.agent }}
    needs: route
    if: needs.route.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Log dispatch
        run: |
          echo "Dispatching to agent: ${{ needs.route.outputs.agent }}"
          echo "Workflow: ${{ needs.route.outputs.workflow }}"
          echo "Stage: ${{ needs.route.outputs.stage }}"

      - name: Trigger architect workflow
        if: needs.route.outputs.agent == 'architect'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'architect.yml',
              ref: context.payload.repository.default_branch,
              inputs: {
                issue_number: String(context.payload.issue.number),
                workflow_type: '${{ needs.route.outputs.workflow }}',
                stage: '${{ needs.route.outputs.stage }}'
              }
            });
            console.log('Triggered architect workflow');

      - name: Trigger engineer workflow
        if: needs.route.outputs.agent == 'engineer'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'engineer.yml',
              ref: context.payload.repository.default_branch,
              inputs: {
                issue_number: String(context.payload.issue.number),
                workflow_type: '${{ needs.route.outputs.workflow }}',
                stage: '${{ needs.route.outputs.stage }}'
              }
            });
            console.log('Triggered engineer workflow');

      - name: Trigger reviewer workflow
        if: needs.route.outputs.agent == 'reviewer'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'reviewer.yml',
              ref: context.payload.repository.default_branch,
              inputs: {
                issue_number: String(context.payload.issue.number),
                workflow_type: '${{ needs.route.outputs.workflow }}',
                stage: '${{ needs.route.outputs.stage }}'
              }
            });
            console.log('Triggered reviewer workflow');

      - name: Trigger UX designer workflow
        if: needs.route.outputs.agent == 'ux-designer'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ux-designer.yml',
              ref: context.payload.repository.default_branch,
              inputs: {
                issue_number: String(context.payload.issue.number),
                workflow_type: '${{ needs.route.outputs.workflow }}',
                stage: '${{ needs.route.outputs.stage }}'
              }
            });
            console.log('Triggered UX designer workflow');

      - name: Trigger Product Manager workflow
        if: needs.route.outputs.agent == 'product-manager'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'run-product-manager.yml',
              ref: context.payload.repository.default_branch,
              inputs: {
                issue_number: String(context.payload.issue.number),
                issue_title: context.payload.issue.title,
                issue_body: context.payload.issue.body || ''
              }
            });
            console.log('Triggered Product Manager workflow');

      - name: Post dispatch comment
        uses: actions/github-script@v7
        with:
          script: |
            const agent = '${{ needs.route.outputs.agent }}';
            const stage = '${{ needs.route.outputs.stage }}';
            const workflow = '${{ needs.route.outputs.workflow }}';
            
            const agentEmoji = {
              'product-manager': 'üéØ',
              'architect': 'üèóÔ∏è',
              'engineer': 'üíª',
              'reviewer': 'üîç',
              'ux-designer': 'üé®'
            };
            
            const comment = `## ${agentEmoji[agent] || 'ü§ñ'} Agent Dispatched: ${agent.charAt(0).toUpperCase() + agent.slice(1)}

            **Workflow**: ${workflow}  
            **Stage**: ${stage}

            The ${agent} agent has been triggered and will process this issue.

            ---
            <sub>ü§ñ Orchestrated by AgentX | [Pause](/pause) | [Skip](/skip ${agent})</sub>`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: comment
            });

